# Bringing Paths into scope with the `use` keyword

### Instead of use module paths and writing those lengthy paths everytime, we can use the `use` keyword to bring paths into scope. And then we can just use the last word of that path and call it and its methods directly.

### For example :
```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting; //since we defined it, we can just use lastname everywhere now

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
```

## Providing new names with the `as` keyword
```rust
use std::io::Result as IoResult;

fn function() -> IoResult<()> {
    // --snip--
}
```

## Re-exporting Names with pub use

### we can re-export names with `pub use` this will make the name available to external crates as well.
```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
```

## Using Nested Paths to Clean Up Large use Lists
#### instead of doing
```rust
// --snip--
use std::cmp::Ordering;
use std::io;
// --snip--
```

#### we can just do
```rust
// --snip--
use std::{cmp::Ordering, io};
// --snip--
```

### Another example:
```rust
use std::io;
use std::io::Write;

// instead use
use std::io::{self, Write};
```

## The Glob operator

### if we want to bring all the public items into scope, we can use the glob operator `*`
```rust
use std::collections::*;
```
