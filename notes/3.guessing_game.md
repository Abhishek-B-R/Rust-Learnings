# Guessing Game

```rust
use std::io;

fn main() {
    println!("Guess the number");
    println!("Enter a number");

    let mut guess = String::new();

    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read nuber");

    println!("Guessed number is {guess}");

}
```

### So this is the entire codebase, let's break it down neatly.

## use std::io; -> is a standard rust library for input/output operations.
## use rand::Rng; -> is a standard rust library for random number generation.

# **In rust variables are immutable by default, but can be made mutable using the mut keyword.**
## That's why we use **mut** keyword while declaring above variable. **let** is used to declare a variable.

## String::new() is used to create a new empty string. **String::new()** creates a new empty string. And **=** is used to assign a value to a variable.

# Recieving a user input :
## We need std::io::stdin() to recieve user input. (we can import std::io and then called io::stdin()      or       we can import std::io::stdin() and then just call it as stdin()      or     we can just call it as std::io::stdin() whereever we want to use it)
## Then we have read_line() fn which is from stdin() object. Which takes the address of the variable wherein we want to store the input.

## And the arg we are sending is **&mut guess**. **&mut** is used to pass a mutable reference(addresses are also immutable by default) to a variable. **&** is used to pass a reference to a variable.
## And **.expect("Failed to read number");** is error handler which handles the error if the user input is not a number.


## read_line() function returns what the user enters into the string and also it returns a Result type (Enum) which is either Ok or Err. If it's Ok then it returns the number of bytes read and if it's Err then it returns the error.

## println! with flower braces, it can be used in two ways-
- ### println!("Guessed number is {guess}"); => Guessed number is 12 (for eg)
- ### println!("Guessed number is {}", guess); => Guessed number is 12 (for eg)

# Now for next part we add random number guessing, for that update cargo.toml and add rand = "0.8.5"
# And then code additions are :
```rust
use rand::Rng;
fn main() {
    let secret_number = rand::thread_rng().gen_range(1..=100);
    println!("The secret number is: {secret_number}");
}
```

## Now here, rand is an external package, in rust external packages are called crates. So, rand is a crate. Rng is a trait, treat it as a blackbox for now.

## rand::thread_rng() is a function which returns a random number generator. But it has infinite range, so to fix it, we use gen_range fn

## gen_range() takes two arguments, the lower bound and the upper bound. But since upper bound is exclusive, we either have to send it as **1..101** or **1..=100**.
## Wherein, 1.. means starting from 1 all next numbers, and =100 means from until 100 and including 100.

### Examples :
- 1..5 => 1, 2, 3, 4
- 1..=5 => 1, 2, 3, 4, 5
- ..5 => 0, 1, 2, 3, 4 (nothing means from 0)
- 1.. => 1, 2, 3, ....(infinity)
- ..=5 => 0, 1, 2, 3, 4, 5


# Now let's add another package called cmp, new code additions are:
```rust
use std::cmp::Ordering;
fn main() {
    let guess : i32 = guess.trim().parse().expect("Please enter a number");
    match guess.cmp(&secret_number){
        Ordering::Less => println!("Too small"),
        Ordering::Greater => println!("Too big"),
        Ordering::Equal => println!("You win!"),
    }
}
```

## here cmp is a new package with Ordering as an enum. It has three variants: Less, Greater, and Equal.
# In rust we can **override** any variable with new data, here guess was already initialized as string, but we have changed it to i32.

## Now while re-initializing, :i32 says that the number is 32-bit integer, and trim() removes whitespaces from the string, and parse() removes that extra "\n" that we get from the input.
## Then we use **match** to compare the guess with the secret number. Then we give respective output based on the comparison.
