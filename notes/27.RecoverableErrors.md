# Recoverable errors

### These errors can be handled at runtime and the program can continue execution after handling them. For example, when a file is not found, we can prompt the user to enter a new file name or exit the program gracefully.

```rust
use std::fs::File;

fn main() {
    let greeting_file_result = File::open("hello.txt");
    
    let file = match greeting_file_result{
        Ok(file) => file,
        Err(error) => panic!("Problem opening the file: {error:?}"),
    };

    println!("{:?}", file);
}
```

#### Here we can do various other things other than using `panic` macro, like creating a new file or logging the error. We can do it like this:
```rust
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file_result = File::open("hello.txt");
    
    let file = match greeting_file_result{
        Ok(file) => file,
        Err(error) => match error.kind() {
            ErrorKind::NotFound => match File::create("hello.txt") {
                Ok(file) => file,
                Err(error) => panic!("Problem creating the file: {error:?}"),
            },
            _ => panic!("Problem opening the file: {error:?}"),
        },
    };

    println!("{:?}", file);
}
```

### So here we use `match` 3 times, once to check if file is accessible or not, second time to check what type of error has occurred while accessing the file and third time to check if file creation was successful or not.

#### There is a better way to handle Result<T, E>, which are called **closures**. It is learn't in future but here is a alternate code using closures:
```rust
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file = File::open("hello.txt").unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create("hello.txt").unwrap_or_else(|error| {
                panic!("Problem creating the file: {error:?}");
            })
        } else {
            panic!("Problem opening the file: {error:?}");
        }
    });
}
```

## Shortcuts for Panic on Error: `unwrap` and `expect`:
## `unwrap`

#### It is used instead of calling `match` keyword again and again, this makes our code much more readable and consise. Here, it returns `Ok(file)` if file is accessible or `Err(error)` if file is not accessible.

Here is the implementation of previous simple code using `unwrap`
```rust
use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt").unwrap();
}
```

## `expect`
#### It is similar to `unwrap` but it takes a string as an argument which is printed when the program panics. This makes our code more readable and consise. Here, it returns `Ok(file)` if file is accessible or `Err(error)` if file is not accessible.

Here is the implementation of previous simple code using `expect`
```rust
use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt").expect("Failed to open hello.txt");
}
```

## Propagating Errors

#### We can return `Errors` to the parent function by using either **return** or **?** operator.
```rust
fn read_username_from_file() -> Result<String, io::Error>{
    let username_file_result = File::open("hello.txt");

    let mut username_file = match username_file_result{
        Ok(file) => file,
        Err(error) => return Err(error),
    };

    let mut username = String::new();

    match username_file.read_to_string(&mut username){
        Ok(_) => Ok(username),
        Err(e) => Err(e),
    }
}
```

#### So, this is a function that reads the contents of a file and returns it as a string. If there was any error, it will be propagated to the parent function.
### We can make it more concise by using `?` operator.
```rust
fn read_username_from_file_simpler() -> Result<String, io::Error> {
    let mut username_file = File::open("hello.txt")?;
    let mut username = String::new();

    username_file.read_to_string(&mut username)?;
    Ok(username)
}
```

### It can be simplified even further by using multiple `?` operators inline and by using `fs::read_to_string` function.
```rust
fn read_username_from_file_more_simpler() -> Result<String, io::Error>{
    let mut username = String::new();
    File::open("hello.txt")?.read_to_string(&mut username)?;
    Ok(username)
}

fn read_username_from_file_simplest() -> Result<String, io::Error> {
    fs::read_to_string("hello.txt")
}
```

## Where the `?` operator is used
### It can be used only when the parent function returns a `Result` type. And it handles correctly both - Ok and Err cases. If we use it on main() fn, compiler will complain and throw an error.

```rust
use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt")?;
}//   | --------- this function should return `Result` or `Option` to accept `?`
```

## But main function can return `Result<(), Box<dyn Error>>` so, we can modify the above code a little bit and make it work.
```rust
use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt")?;
    Ok(())
}
```