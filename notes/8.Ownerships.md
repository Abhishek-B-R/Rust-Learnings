# Ownership and Borrowing

### Ownership is a set of rules that govern how data is managed in Rust. These rules ensure memory safety and prevent common programming errors like null pointer dereferences and data races.

## The Stack and the Heap

The stack is a region of memory that grows and shrinks as functions are called and returned. It is used to store local variables and function parameters. The stack is managed automatically by the compiler and is very fast. All the data that we store there needs to be fully knownand should have fixed sizes. Data with unknown sizes or variable lengths are stored on the heap.

The heap is a region of memory that is used to store data that is allocated dynamically. It is used to store data that is too large to fit on the stack or data that needs to be shared between functions. The heap is managed manually by the programmer and is slower than the stack. The storage and retrieval of data on the heap is slower than on the stack, but it allows for more flexibility in terms of memory usage. It's not necessary that all the data on heap is stored nearby each other. Data can be scattered across the heap, and the programmer is responsible for managing the memory manually. So, its slower.


## Ownership rules:
- Each value in Rust has an owner.
- There can only be one owner at a time.
- When the owner goes out of scope, the value will be dropped.


## Variable Scope
```Rust
{                      // s is not valid here, since it's not yet declared
    let s = "hello";   // s is valid from this point forward
    // do stuff with s
}                      // this scope is now over, and s is no longer valid
```
## Memory allocation variations
#### You may think both of these below codes are the same.
```rust
let mut x = "asdf";
let mut y = String::from("asdf");
```
#### but no they are not, x is a string literal, y is a String object. which means, y is mutable, x is immutable. y is stored in the heap, x is hardcoded in the final executable(assume as program).
### So, this is valid code.
```rust
let mut s = String::from("hello");
s.push_str(", world!"); // push_str() appends a literal to a String
println!("{s}"); // this will print `hello, world!`
```

## Whenever any heap allocation goes out of scope, ie no owner, it will be dropped.
## Copying variables in Rust
```rust
let x = 5;
let y = x;

let z = "asdf";
let w = z;
```

### Here x and y have same value as 5 and updating one doesn't affect the other. But for z and w, the case if very different. As soon as we copy z's content to w, z becomes **moved** variable, ie, it cannot be used any further. This process is also called **move**. When a variable is moved, the ownership of the data is transferred to the new variable. Here only the pointer is moved from z to w, and z is made obsolete. This means that the original variable is no longer valid and cannot be used. This is done to prevent double free errors.(double dropping)

#### This is process is different from other languages, as others use shallow copy and deep copy, wherein shallow means both variables share the same memory location, and deep means a new copy of the data is created. Deep copy is same in Rust but Shallow copy is replaced by **move**.
## If you assign some value to s1 and then pass it as a parameter to a function, the ownership of s1 is transferred to the function. This means that s1 is no longer valid after the function call. This is also called a **move**.
### In order to use both z and w, we need to clone z. This will create a new copy of string of z's content.
```rust
let z = "asdf";
let w = z.clone();
```


## Wherever we create a variable with some string data(as strings are stored in Heap because their data length is unknown), and then replace that data with something else, the original data is dropped.
```rust
let mut s = String::from("hello");
s = String::from("Hola");

// now since new data is added to s, the old data is dropped. So, the declaration of "hello" in Heap is dropped.
```

## Stack-only Data Copy
```rust
let x = 5;
let y = x;

println!("x = {x}, y = {y}"); // works perfectly fine without needing x.clone() method
// this is bcse the values are stored in stack, and stack is copied by value, not by reference. Datatypes like i32, f64, bool, char, tuples of those types are stored in stack. Datatypes like String, Vec, Box, Rc, Arc, RefCell, Mutex, RwLock are stored in Heap.
```



# There are some really cool examples to understand ownership and borrowing in Rust. Here is the [link](https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#ownership-and-functions)
