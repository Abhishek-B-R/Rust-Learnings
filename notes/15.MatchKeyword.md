# Rust has a very powerful control flow construct called **match**.

## **match** controls the flow of your program based on different cases. For ex:
```rust
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin { // match keyword with the variable on which it is applied
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
```
### Here, **match** is used to handle different cases of the `Coin` enum. It allows us to specify different actions for each case, making our code more readable and maintainable. It controls how the program responds to different cases of the `Coin` enum.
## It might look similar to **if** statements, but **match** is more powerful and flexible. For **if** statements, you need boolean expressions to control the flow of your program. **match** can handle any type of value.

### **match arm** is a pattern that is matched against the value of the expression being evaluated by the **match** expression. Each **match arm** consists of a **pattern** and an **expression** separated by a => symbol. When the **match** expression is evaluated, each **match arm** is considered in order until a pattern matches the value. The expression associated with the matching pattern is then evaluated and returned as the result of the **match** expression.

#### Here, Coin::Penny => 1 is the first match arm.

## The expression in this match arm is similar to **lambda** expressions in other languages. It allows us to define a function inline without having to declare it separately. This makes our code more concise and easier to read. If there are more than one statements, then use {} to enclose them.
```rust
Coin::Penny => {
    println!("Lucky penny!");
    1
}
```

## Matching with **Option<T>**
```rust
fn plus_one(x: Option<T>) -> Option<T> {
    match x {
        Some(i) => Some(i + 1),
        None => None,
    }
}

let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
```
### In this manner, we can control the flow of our program based on the value of **Option** keyword being evaluated by the **match** expression.

## Combining match and enums is useful in many situations. You’ll see this pattern a lot in Rust code: match against an enum, bind a variable to the data inside, and then execute code based on it.


## Matches are exhaustive
### There’s one other aspect of match we need to discuss: the arms’ patterns must cover all possibilities. If we forget to handle a case, Rust will warn us about it. This ensures that we don’t miss any cases, which can lead to bugs.

## Catch all pattern and the **_** pattern
### Imagine a game with guess a number between 1 and 100. If the number is 3, you win, if its 7 you can retry, but if any other number is guessed, you lose. To do this using match expression, we can use the **_** pattern to match any value that doesn’t match any other pattern.
```rust
let dice_roll = 3;
match dice_roll {
    3 => println!("You win!"),
    7 => println!("You can retry!"),
    _ => println!("You lose!"), // here _ is used as a catch all pattern
}
```
