## Methods are functions that are defined within the context of a struct, enum, or trait. They are used to define behavior for instances of those types.
```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
    fn width(&self) -> bool {
        self.width > 0
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of rectangle is {} and width is {}",
        rect1.area(), rect1.width()
    );
}
```

### Here, we define a method `area` on the `Rectangle` struct. The `&self` parameter is a reference to the instance of the struct on which the method is called. The method returns the area of the rectangle as a `u32`.
### Also we can define methods with same name as our variables, `width` and `height`. Rust provides a way to define methods with the same name as our variables, but it's important to note that these methods are not the same as the variables themselves. They are just methods with the same name as our variables. Usage depends on usage of parentheses or not.

## Methods with same name as the variables are called **getters**. They are used to retrieve the value of a field. And generally, they are used to access the value of a field without modifying it and have no other purpose.
## **Getters** are used because the variables are private and we can't access them directly. We can only access them through the methods.


# Automatic Referencing of Methods
### Whenever you define a method on a struct, enum, or trait, Rust automatically provides a way to call that method on an instance of that type. This is called **automatic referencing**. We don't need to worry about the details of how Rust handles this, but it's important to understand that it's happening behind the scenes. Like:
```rust
struct Point {
    a: u32,
}

impl Point {
    fn distance(&self) -> u32 {
        self.a
    }
}

fn main() {
    let p1 = Point { a: 5 };     // a normal value
    let p2 = &Point { a: 10 };   // a reference to a Point

    println!("{}", p1.distance());  // works directly on value
    println!("{}", p2.distance());  // also works, even though p2 is a reference
    // it is exquivalent to (&p2).distance(); but rust automatically dereferences the reference for us
}
```

### Here, we defined p1 normally, but p2 is a reference to a Point. We can call the distance method on p2 because Rust automatically dereferences the reference for us. This is called **automatic dereferencing**. We don't need to worry about the details of how Rust handles this, but it's important to understand that it's happening behind the scenes.


## Associated functions
### Associated functions are functions that are defined on a struct, enum, or trait, but they don't have a self parameter. They are used to create new instances of a struct or enum, or to perform other operations that don't require an instance of the struct or enum. Examples are constructors and static methods.
```rust
impl Rectangle {
    fn square(size: u32) -> Self { // no &self is passed as a parameter
        Self {
            width: size,
            height: size,
        }
    }
}
```

## Another thing, we can have multiple **impl** blocks for the same struct.
```rust
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}
```

### The above code is completely valid.
