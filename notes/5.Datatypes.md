# Data Types in Rust
There are 2 types:

## Scalar Types :
### Integer Types:

| Signed Integer Types | Unsigned Integer Types |
|-----------------------|------------------------|
| i8                    | u8                     |
| i16                   | u16                    |
| i32                   | u32                    |
| i64                   | u64                    |
| i128                  | u128                   |
| isize                 | usize                  |

### You can also specify numeric types by adding suffix while assigning values:
```Rust
let x = 5i32; // Signed integer type
let y = 3.14f64; // Floating-point type
let z = 10u8; // Unsigned integer type
```

## If you're unsure about the size of an integer type, you can use i32 or u32.

## Integer overflow situations:

| Method Type         | Behavior                                      | Example                                  | Use Case                                                                         |
| ------------------- | --------------------------------------------- | ---------------------------------------- | -------------------------------------------------------------------------------- |
| **`wrapping_*`**    | Wraps around on overflow (modular arithmetic) | `255u8.wrapping_add(1) == 0`             | When overflow is intended, like implementing cyclic counters or hashes           |
| **`checked_*`**     | Returns `None` if overflow happens            | `255u8.checked_add(1)` → `None`          | When overflow is an **error condition** you want to detect safely                |
| **`overflowing_*`** | Returns `(result, overflow_bool)`             | `255u8.overflowing_add(1)` → `(0, true)` | When you need both the wrapped result **and** to know if overflow occurred       |
| **`saturating_*`**  | Clamps to min/max instead of wrapping         | `255u8.saturating_add(1)` → `255`        | When values must stay within safe bounds (e.g., color channels, sensor readings) |



### We have other types also like Float, Boolean, Char:

#### Floating-Point Types:
    - f32
    - f64

#### Boolean Type:
    - bool

#### Character Type:
    - char


## Compound Types :
### Tuple Types:
    Tuple types are used to group multiple values into a single type.

#### Tuple Types:
    - (T1, T2, ..., Tn)

```Rust
fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
    let tup2 = (500, 6.4, 1);
}
```

### Array Types:
    Array types are used to store a fixed-size sequence of elements of the same type.

#### Array Types:
    - [T; N]

```Rust
fn main() {
    let arr: [i32; 5] = [1, 2, 3, 4, 5];
    let arr2 = [1, 2, 3, 4, 5];
}
```

#### If we enter a invalid array index and try accessing it, it will panic and exit from the program. Many other low level languages like C/C++ will not do this and will just return garbage values. Rust prevents this by checking array bounds at runtime. This is an example of Rust’s memory safety principles in action
