# Strings

### Rust has only one String type at its core, called as **str**, its the String Slice type. It is a reference to a sequence of characters stored in memory. It is immutable and can be used to represent a string literal or a string slice.

### The **String** type, which is provided by Rust’s standard library rather than coded into the core language, is a growable, mutable, owned, UTF-8 encoded string type

## **String** type:

#### It has same operations as `Vec<T>` and indeed has even more operations than `Vec<T>`. It also provides additional methods for string manipulation and formatting.
```rust
let mut s = String::new();
```

#### This cmd creates an empty string which is mutable, but if we already have a string with some value, we can use either of these ways to create a new String from an existing one:
```rust
let s = String::from("Hello");
let s = "Hello".to_string();
```

### Since the **String** type is UTF-8 encoded, it can store any valid UTF-8 sequence of bytes. This means that it can store any Unicode character, including emojis, mathematical symbols, various other languages and other special characters.


## Updating a String

#### We can conveniently use **+** to concatenate strings, but only condition is - one operand must be a String and the other must be a &str.
#### Or we can use the **format** macro like this :
```rust
let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");

let s = format!("{s1}-{s2}-{s3}");             
```


### We can even use builtin fns like **push_str** and **push** to add more characters to the string.
#### the **push** is used to add a single character to the end of the string.
#### the **push_str** is used to add a string slice to the end of the string. This method doesn't even take ownership of the string slice.

### If we use simple **+** operator, s1 is moved now, so can't be used anymore. But since we passed the reference of s2, we can still use s2. But here to do this concatination, either of them should be moved. We can't move both or prevent both from getting moved.
```rust
let s1 = String::from("Hello, ");
let s2 = String::from("world!");
let s3 = s1 + &s2; // note s1 has been moved here and can no longer be used

// if you wanna join more than 2 strings, then one should be moved and rest can be used as reference. 
let s4 = "bro";
let s5 = "ther";

let s6 = s3 + &s4 + &s5;
``


## Indexing in Rust

### Rust doesn't support indexing into a String. This is because Rust doesn't know the size of the string at compile time. So it can't know how many bytes to look at to get the character at a particular index.
  ```rust
  let s1 = String::from("hi");
  let h = s1[0]; // gives error
```

### This happens because Rust doesn't know how many bytes to look at to get the character at a particular index. Rust doesn't know the size of the string at compile time. So it can't know how many bytes to look at to get the character at a particular index. Also when we query the character of a string, its UTF-8 encoded number is returned which isn't what user requested for and might lead to bugs So, to avoid returning an unexpected value and causing bugs that might not be discovered immediately, Rust doesn’t compile this code at all and prevents misunderstandings early in the development process.

## String slices

```rust
let hello = "Здравствуйте";

let s = &hello[0..4]; // slice is "Зд"
```

### Here, this text is in Russian, and Rust takes 2 bytes to store each character, same goes to any language other than English which takes 1 byte to store each character. 
### Here if we try doing &hello[0..1], Rust would panic at runtime in the same way as if an invalid index were accessed in a vector:

## Methods for iterating over strings

### Rust provides several methods for iterating over strings. Here are some of them:

### 1. chars() method

```rust
let hello = "Здравствуйте";

for c in hello.chars() { // instead of hello[i], use this
    println!("{}", c);
}
```

### 2. bytes() method

```rust
let hello = "Здравствуйте";

for b in hello.bytes() {
    println!("{}", b);
}
```

### 3. split_whitespace() method

```rust
let hello = "Здравствуйте";

for word in hello.split_whitespace() { // if "\n" is detected, its split into a separate word
    println!("{}", word);
}
```