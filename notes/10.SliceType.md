# The Slice Type

### Slices let you reference a contigous sequence of elements in a collection(vector, string, hashmap). A **slice** is also a kind of reference so it doesn't have ownerships.
## String Slicing:

```rust
let s = String::from("hello world");
let hello = &s[0..5];
let world = &s[6..11];
```
Here, slicing a string in Rust is similar to that of Python. But here we can't slice negative indices and have to pass address of the first element.
#### This is how slicing actually works:
<img src="https://doc.rust-lang.org/book/img/trpl04-07.svg" alt="drawing" width="400"/>

### Let's do an activity
```rust
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s); // word will get the value 5

    s.clear(); // this empties the String, making it equal to ""

    // word still has the value 5 here, but s no longer has any content that we
    // could meaningfully use with the value 5, so word is now totally invalid!
}
```

#### Here since "s" is empty, the value of word is invalid. This is a vulnerability in our program. We can't use word anymore.

## Rust's ".." syntax

### If start index is not provided, it defaults to 0.
### If end index is not provided, it defaults to the length of the collection.
## So,
```rust
let s = String::from("hello world");
let hello = &s[0..5];        //is similar to &s[..5]
let world = &s[6..11];       //is similar to &s[6..]
```


## So now, we can fix the above issue/vulnerability with the help of Rust's ".." syntax.
```rust
fn main() {
    let mut s = String::from("hello there");
    let first = first_word(&s); // borrowing and recieve first work

    s.clear();
    println!("{}", first); //print it
}

fn first_word(s : &String) -> &str{ // take immutable reference of string and return string
    let bytes = s.as_bytes(); // split it into bytes array

    for (i, &byte) in bytes.iter().enumerate() { // iterate the bytes and enumarate it -> gives index and
        if byte == b' ' { // here b' ' means the bytecode of space(' ')
            return &s[0..i]; // return the first part of the string, bia reference obv
        }
    }

    return &s[..]; // if no space found, return entire s
}
```

## Here in this above code, **str** keyword is called as String Slice Type and **&str** is called as String Slice Type Reference. It is used
### Here the parameter **s** in fn first_word can be either &str or &String, both works and experienced devs prefer &str over &String in this context.



## Other Slices
```rust
let a = [1, 2, 3, 4, 5];

let slice = &a[1..3];

assert_eq!(slice, &[2, 3]);
```

### Other slices are also similar to String Slices, they are also references to a part of a collection. It doesn't have a dedicated type, it is just a reference to a part of a collection.

# Summary
### The concepts of ownership, borrowing, and slices ensure memory safety in Rust programs at compile time. The Rust language gives you control over your memory usage in the same way as other systems programming languages, but having the owner of data automatically clean up that data when the owner goes out of scope means you donâ€™t have to write and debug extra code to get this control.
