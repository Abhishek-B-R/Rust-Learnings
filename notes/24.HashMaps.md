# HashMaps

### HashMaps are a data structure that allows you to store key-value pairs. They are implemented using a hash table, which provides constant time complexity for insertion, deletion, and lookup operations.

### In rust to use `HashMap<K, V>` we have to import the `HashMap` struct from the `std::collections` module.

## Creating a new HashMap
```rust
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);
```

#### Like vectors, HashMaps are also growable. HashMaps are also indexed by a key, which can be of any type that implements the `Eq` and `Hash` traits. All `keys` must be of the same type. All `values` must be of the same type.

## Accessing Values in a Hash Map

#### We can use `get` to retrieve a value from a HashMap.
```rust
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);

let team_name = String::from("Blue");
let score = scores.get(&team_name).copied().unwrap_or(0);
```

#### `get` method returns an `Option<&V>`; if there’s no value for that key in the hash map, get will return `None`. This program handles the `Option` by calling copied to get an `Option<i32>` rather than an `Option<&i32>`, then unwrap_or to set score to zero if scores doesn’t have an entry for the key.

### We can iterate over the HashMap using a for loop:
```rust
use std::collections::HashMap;

let mut scores = HashMap::new();
scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);

for (key, value) in &scores {
    println!("{key}: {value}");
}
```

## HashMaps and Ownership
#### For types that implement the Copy trait, like i32, the values are copied into the hash map. For owned values like String, the values will be moved and the hash map will be the owner of those values

```rust
use std::collections::HashMap;

let field_name = String::from("Favorite color");
let field_value = String::from("Blue");

let mut map = HashMap::new();
map.insert(field_name, field_value);
// field_name and field_value are invalid at this point, try using them and
// see what compiler error you get!
```

#### To prevent this behaviour, we can use references.


## Updating a HashMap
#### Each key must have only one value associated with it at any given time, but not vice versa. So, if we insert the same key twice, the value associated with that key will be overwritten.
```rust
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Blue"), 25);

println!("{scores:?}"); // prints 25 , 10 got overrided
```

#### In order to prevent this behaviour and to update a key only if it doesn't exist, we can use the `entry` and `or_insert` method.
```rust
use std::collections::HashMap;

let mut scores = HashMap::new();
scores.insert(String::from("Blue"), 10);

scores.entry(String::from("Yellow")).or_insert(50);
scores.entry(String::from("Blue")).or_insert(50);

println!("{scores:?}"); // prints {"Blue": 10, "Yellow": 50} // since Blue already exists, it's value is not updated
```

### Updating a Value Based on the Old Value
#### We can use the `entry` method and `or_insert` method to update a value based on the old value. We can check if the key exists and if it does, we can update the value. And if not we can insert a default value.
```rust
use std::collections::HashMap;

let text = "hello world wonderful world";
let mut map = HashMap::new();

for word in text.split_whitespace() {
    let count = map.entry(word).or_insert(0);
    *count += 1;
}
println!("{map:?}");  // {"world": 2, "hello": 1, "wonderful": 1}
```

## Hashing Functions

#### By default, Rust uses a hashing function called SipHash. It is a cryptographic hash function that is designed to be secure against collision attacks. This is not the fastest hashing algorithm available, but the trade-off for better security that comes with the drop in performance is worth it. 


### We can use `hasher` is a type that implements the **BuildHasher** trait