# Vector 

## We can create a vector in two ways:
- Using the `vec!` macro
- Using the `Vec::new()` method

### We use `vec!` macro when we want to create a vector with initial elements. 
### We use `Vec::new()` method when we want to create an empty vector.
### Example :
```rust
let v1 : Vec<i32> = Vec::new();
let v2 = vec![1,2,3,4,5];
```

## We can later add many more values to these vectors if we declare them as mutable.
```rust
let mut v3 = Vec::new();
v3.push(1);
v3.push(2);
```

## We can print vectors using the `println!` macro using this format `println!("{:?}", v1);`

## Reading Elements from Vectors

### We can store the elements of a vector in a variable using the `&` operator. And then use them. 

```rust
let v = vec![1, 2, 3, 4, 5];

let third: &i32 = &v[2];
println!("The third element is {third}"); // unsafe way, might throw errors

let third: Option<&i32> = v.get(2);
match third {
    Some(third) => println!("The third element is {third}"),
    None => println!("There is no third element."),
} // safer way with error handling
```
### Or, we can use the `get` method to access the elements of a vector.
```rust
let v = vec![1, 2, 3, 4, 5];

let does_not_exist = &v[100];
let does_not_exist = v.get(100);
```

### This `get` method returns an `Option<&T>` type, which means it can either return a reference to the element at the specified index or `None` if the index is out of bounds.


## Borrowing Rules on Vectors
```rust
let mut v = vec![1, 2, 3, 4, 5];

let first = &v[0];

v.push(6);

println!("The first element is: {first}"); // this throws errors
```
##### The code in Listing 8-6 might look like it should work: why should a reference to the first element care about changes at the end of the vector? This error is due to the way vectors work: because vectors put the values next to each other in memory, adding a new element onto the end of the vector might require allocating new memory and copying the old elements to the new space, if there isnâ€™t enough room to put all the elements next to each other where the vector is currently stored. In that case, the reference to the first element would be pointing to deallocated memory. The borrowing rules prevent programs from ending up in that situation.

## Iterating over the values in a vector

#### To iterate over a vector, we can use a simple for loop:
```rust
let v = vec![100, 32, 57];
for i in &v {
    println!("{i}");
}
```

#### If we want to modify the values in the vector, we can use a mutable reference:
```rust
let mut v = vec![100, 32, 57];
for i in &mut v {
    *i += 50;
}
```

#### If we want to iterate over the values in a vector and also get the index of each element, we can use the `iter` method:
## This isn't covered yet, it will covered in future in **Iterators and Closures lesson**
```rust
let v = vec![100, 32, 57];
for (i, &item) in v.iter().enumerate() {
    println!("Index: {i}, Value: {item}");
}
```

## Using an Enum to Store Multiple Types

#### We can only store one type of data in a vector, but if we want to store multiple types in a vector, we can use an enum:
```rust
enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}

let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from("blue")),
    SpreadsheetCell::Float(10.12),
];
```

## There are various methods that we can use on Vectors like **push**,**pop**, etc. Checkout here - [link](https://doc.rust-lang.org/std/vec/struct.Vec.html) for API documentation.

## Dropping a Vector Drops its Elements
```rust
{
    let v = vec![1, 2, 3, 4];

    // do stuff with v
} // <- v goes out of scope and is freed here
```